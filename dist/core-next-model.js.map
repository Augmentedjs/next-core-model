{"version":3,"sources":["webpack://core-next-model/webpack/universalModuleDefinition","webpack://core-next-model/webpack/bootstrap","webpack://core-next-model/external {\"commonjs\":\"lodash.clone\",\"commonjs2\":\"lodash.clone\",\"amd\":\"lodash.clone\",\"root\":\"lodash.clone\"}","webpack://core-next-model/./src/model/abstractModel.js","webpack://core-next-model/external {\"commonjs\":\"next-core-object\",\"commonjs2\":\"next-core-object\",\"amd\":\"next-core-object\",\"root\":\"next-core-object\"}","webpack://core-next-model/external {\"commonjs\":\"next-core-utilities\",\"commonjs2\":\"next-core-utilities\",\"amd\":\"next-core-utilities\",\"root\":\"next-core-utilities\"}","webpack://core-next-model/external {\"commonjs\":\"next-core-validation\",\"commonjs2\":\"next-core-validation\",\"amd\":\"next-core-validation\",\"root\":\"next-core-validation\"}","webpack://core-next-model/./src/collection/iterator.js","webpack://core-next-model/./src/index.js","webpack://core-next-model/external {\"commonjs\":\"lodash.result\",\"commonjs2\":\"lodash.result\",\"amd\":\"lodash.result\",\"root\":\"lodash.result\"}","webpack://core-next-model/external {\"commonjs\":\"lodash.isempty\",\"commonjs2\":\"lodash.isempty\",\"amd\":\"lodash.isempty\",\"root\":\"lodash.isempty\"}","webpack://core-next-model/external {\"commonjs\":\"lodash.has\",\"commonjs2\":\"lodash.has\",\"amd\":\"lodash.has\",\"root\":\"lodash.has\"}","webpack://core-next-model/external {\"commonjs\":\"lodash.defaults\",\"commonjs2\":\"lodash.defaults\",\"amd\":\"lodash.defaults\",\"root\":\"lodash.defaults\"}","webpack://core-next-model/external {\"commonjs\":\"lodash.iteratee\",\"commonjs2\":\"lodash.iteratee\",\"amd\":\"lodash.iteratee\",\"root\":\"lodash.iteratee\"}","webpack://core-next-model/external {\"commonjs\":\"lodash.defer\",\"commonjs2\":\"lodash.defer\",\"amd\":\"lodash.defer\",\"root\":\"lodash.defer\"}","webpack://core-next-model/external {\"commonjs\":\"lodash.escape\",\"commonjs2\":\"lodash.escape\",\"amd\":\"lodash.escape\",\"root\":\"lodash.escape\"}","webpack://core-next-model/./src/collection/collection.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__3__","__WEBPACK_EXTERNAL_MODULE__4__","__WEBPACK_EXTERNAL_MODULE__7__","__WEBPACK_EXTERNAL_MODULE__8__","__WEBPACK_EXTERNAL_MODULE__9__","__WEBPACK_EXTERNAL_MODULE__10__","__WEBPACK_EXTERNAL_MODULE__11__","__WEBPACK_EXTERNAL_MODULE__12__","__WEBPACK_EXTERNAL_MODULE__13__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_nextCoreObject","_nextCoreUtilities","_nextCoreValidation","_clone","_result","_isEmpty","_has","_isEqual","_defaults","_iteratee","_defer","_escape","wrapError","model","options","error","resp","AugmentedObject","constructor","attributes","args","attrs","super","id","idAttribute","cidPrefix","defaults","validationError","urlRoot","_pending","_changing","_previousAttributes","_attributes","schema","validationMessages","valid","preinitialize","cid","uniqueId","collection","parse","extend","set","changed","initialize","attribute","val","_validate","console","unset","silent","changes","changing","current","prev","attr","length","trigger","escape","has","matches","clear","toJSON","fetch","success","serverAttrs","sync","save","wait","validate","method","isNew","request","destroy","url","base","urlError","encodeURIComponent","keys","values","clone","hasChanged","changedAttributes","diff","old","previous","previousAttributes","supportsValidation","isValid","_validationFramework","ValidationFramework","v","getValidationMessages","messages","errors","message","reset","data","isEmpty","toString","JSON","update","ITERATOR_VALUES","ITERATOR_KEYS","kind","_collection","_kind","_index","next","at","modelId","done","AbstractModel","AbstractCollection","CollectionIterator","findModelByMatchingProperties","properties","filter","entry","every","setOptions","add","remove","merge","addOptions","models","_byId","comparator","_reset","default","out","singular","Array","removed","_removeModels","added","merged","_isModel","slice","toAdd","toMerge","toRemove","modelMap","sort","sortable","sortAttr","isString","existing","_prepareModel","_addReference","orderChanged","replace","some","index","splice","_removeReference","push","pop","unshift","shift","obj","find","results","where","first","findWhere","Error","isFunction","sortBy","pluck","callbackOpts","entries","ITERATOR_KEYSVALUES","a","sortByKey","sorted","sortObjects","size","ret","e","_onModelEvent","event","prevId","apply","arguments"],"mappings":"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","file":"core-next-model.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash.clone\"), require(\"next-core-object\"), require(\"next-core-utilities\"), require(\"next-core-validation\"), require(\"lodash.result\"), require(\"lodash.isempty\"), require(\"lodash.has\"), require(\"lodash.defaults\"), require(\"lodash.iteratee\"), require(\"lodash.defer\"), require(\"lodash.escape\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"core-next-model\", [\"lodash.clone\", \"next-core-object\", \"next-core-utilities\", \"next-core-validation\", \"lodash.result\", \"lodash.isempty\", \"lodash.has\", \"lodash.defaults\", \"lodash.iteratee\", \"lodash.defer\", \"lodash.escape\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"core-next-model\"] = factory(require(\"lodash.clone\"), require(\"next-core-object\"), require(\"next-core-utilities\"), require(\"next-core-validation\"), require(\"lodash.result\"), require(\"lodash.isempty\"), require(\"lodash.has\"), require(\"lodash.defaults\"), require(\"lodash.iteratee\"), require(\"lodash.defer\"), require(\"lodash.escape\"));\n\telse\n\t\troot[\"core-next-model\"] = factory(root[\"lodash.clone\"], root[\"next-core-object\"], root[\"next-core-utilities\"], root[\"next-core-validation\"], root[\"lodash.result\"], root[\"lodash.isempty\"], root[\"lodash.has\"], root[\"lodash.defaults\"], root[\"lodash.iteratee\"], root[\"lodash.defer\"], root[\"lodash.escape\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__, __WEBPACK_EXTERNAL_MODULE__4__, __WEBPACK_EXTERNAL_MODULE__7__, __WEBPACK_EXTERNAL_MODULE__8__, __WEBPACK_EXTERNAL_MODULE__9__, __WEBPACK_EXTERNAL_MODULE__10__, __WEBPACK_EXTERNAL_MODULE__11__, __WEBPACK_EXTERNAL_MODULE__12__, __WEBPACK_EXTERNAL_MODULE__13__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import { AugmentedObject } from \"next-core-object\";\nimport { extend, uniqueId, allKeys } from \"next-core-utilities\";\nimport { ValidationFramework } from \"next-core-validation\";\n\n// for now\nconst _clone = require(\"lodash.clone\");\nconst _result = require(\"lodash.result\");\nconst _isEmpty = require(\"lodash.isempty\");\nconst _has = require(\"lodash.has\");\nconst _isEqual = require(\"lodash.isequal\");\nconst _defaults = require(\"lodash.defaults\");\nconst _iteratee = require(\"lodash.iteratee\");\nconst _defer = require(\"lodash.defer\");\nconst _escape = require(\"lodash.escape\");\n\nconst wrapError = (model, options) => {\n  if (model) {\n    const error = options.error;\n    options.error = (resp) => {\n      if (error) {\n        error.call(options.context, model, resp, options);\n      }\n      model.trigger(\"error\", model, resp, options);\n    };\n  }\n};\n\n/**\n * AbstractModel <br/>\n * Supports: <ul>\n * <li>Validation and Schemas</li>\n * <li>Security</li>\n * </ul>\n * @extends AugmentedObject\n */\nclass AbstractModel extends AugmentedObject {\n  constructor(attributes, options, ...args) {\n    super(options);\n    this.id = 0;\n    this.idAttribute = \"id\"; // ????\n    this.cidPrefix = \"c\";\n    this.defaults = {};\n    this.validationError = null;\n    this.urlRoot = \"\";\n    this._pending = false;\n    this._changing = false;\n    this._previousAttributes = null;\n    this._attributes = (attributes) ? attributes : {};\n    if (!options) {\n      options = {};\n    }\n\n    this.schema = null;\n    this.validationMessages = {\n     valid: true\n    };\n\n    if (options && options.schema) {\n      this.schema = options.schema;\n    }\n\n    this.preinitialize(args);\n    this.cid = uniqueId(this.cidPrefix);\n    if (options && options.collection) {\n      this.collection = options.collection;\n    }\n    let attrs;\n    if (options && options.parse) {\n      attrs = this.parse(attrs, options) || {};\n    }\n\n    this.defaults = _result(this, \"defaults\");\n    attrs = _defaults(extend({}, this.defaults, attrs), this.defaults);\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize(args);\n  };\n\n  /**\n   * Schema property\n   * @property {object} schema The JSON schema from this model\n   */\n\n  /**\n   * Validation Message property\n   * @property {object} validationMessages The property holding validation message data\n   */\n\n\n  preinitialize(...args) {\n  };\n\n  initialize(...args) {\n  };\n\n  /** Get the attribute form the Model\n   * @returns {any} The model attribute\n   */\n  get(attribute) {\n    return this._attributes[attribute];\n  };\n\n  /** Set a hash of model attributes on the object, firing `\"change\"`. This is\n   * the core primitive operation of a model, updating the data and notifying\n   * anyone who needs to know about the change in state.\n   */\n  set(key, val, options) {\n    // need stack trace for this:\n    /*try {\n      throw new Error(\"calling set.\");\n    } catch(e) {\n      console.debug(e);\n    }*/\n\n    if (key === null) {\n      return this;\n    }\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    let attrs;\n    if (typeof key === \"object\") {\n      attrs = key;\n      options = val;\n      //console.debug(\"key is an object\", attrs);\n    } else {\n      (attrs = {})[key] = val;\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    //console.debug(\"model change attrs\", attrs);\n\n    // Run validation.\n    if (!this._validate(attrs, options)) {\n      console.warn(\"Model did not validate\");\n      return false;\n    }\n\n    // Extract attributes and options.\n    const unset      = options.unset;\n    const silent     = options.silent;\n    const changes    = [];\n    let changing   = this._changing;\n    this._changing = true;\n\n    if (!changing) {\n      this._previousAttributes = _clone(this._attributes);\n      this.changed = {};\n    }\n\n    let current = this._attributes;\n    let changed = this.changed;\n    const prev    = this._previousAttributes;\n\n    let attr;\n    // For each `set` attribute, update or delete the current value.\n    for (attr in attrs) {\n      //console.debug(\"attr to set\", attr);\n      val = attrs[attr];\n      //console.debug(\"attr value set\", attrs[attr]);\n      //console.debug(\"current[attr], val\", current[attr], val);\n      if ( (typeof current[attr] === \"string\") && (typeof val === \"string\") && current[attr] !== val ) {\n        changes.push(attr);\n      } else if (!_isEqual(current[attr], val)) {\n        //console.debug(\"notequal current[attr], val\", current[attr], val);\n        changes.push(attr);\n      }\n      //console.debug(\"prev[attr], val\", prev[attr], val);\n      if ( (typeof prev[attr] === \"string\") && (typeof val === \"string\") && prev[attr] !== val ) {\n        changed[attr] = val;\n      } else if (!_isEqual(prev[attr], val)) {\n        //console.debug(\"assign changed[attr]\", val);\n        changed[attr] = val;\n      } else {\n        //console.debug(\"deleted changed[attr]\");\n        delete changed[attr];\n      }\n      if (unset) {\n        //console.debug(\"unset deleted current[attr]\");\n        delete current[attr];\n      } else{\n        //console.debug(\"assign current[attr]\", val);\n        current[attr] = val;\n      }\n    }\n\n    // Update the `id`.\n    if (this.idAttribute in attrs) {\n      this.id = this.get(this.idAttribute);\n    }\n\n    // Trigger all relevant attribute changes.\n    if (!silent) {\n      //console.debug(\"model set: not silent\");\n      //console.debug(\"model changes to act on\", changes);\n      if (changes.length) {\n        this._pending = options;\n      }\n      let i = 0;\n      for (i = 0; i < changes.length; i++) {\n        this.trigger(\"change:\" + changes[i], this, current[changes[i]], options);\n      }\n    }\n\n    // You might be wondering why there's a `while` loop here. Changes can\n    // be recursively nested within `\"change\"` events.\n    if (changing) {\n      return this;\n    }\n    if (!silent) {\n      while (this._pending) {\n        options = this._pending;\n        this._pending = false;\n        this.trigger(\"change\", this, options);\n      }\n    }\n    this._pending = false;\n    this._changing = false;\n    return this;\n  };\n\n  /** Escape the attribute data\n   */\n  escape(attribute) {\n    return _escape(this.get(attr));\n  };\n\n  /** Has an attribute in the Model\n   * @returns {bolean} Returns true if exists\n   */\n  has(attribute) {\n    return this.get(attr) !== null;\n  };\n\n  /** Special-cased proxy to underscore's `matches` method.\n   */\n  matches(attrs) {\n    return !!_iteratee(attrs, this)(this._attributes);\n  };\n\n  /** Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n   * if the attribute doesn't exist.\n   */\n  unset(attr, options) {\n    return this.set(attr, void 0, extend({}, options, {unset: true}));\n  };\n\n  /** Clear all attributes on the model, firing `\"change\"`.\n   */\n  clear(options) {\n    let attrs = {};\n    for (let key in this._attributes) attrs[key] = void 0;\n    return this.set(attrs, extend({}, options, {unset: true}));\n  };\n\n  /**\n   * Transforms model to pure toJSON\n   */\n  toJSON() {\n    return _clone(this._attributes);\n  };\n\n  //– sync x\n\n  /** Fetch the model from the server, merging the response with the model's\n   * local attributes. Any changed attributes will trigger a \"change\" event.\n   */\n  fetch(options) {\n    options = extend({parse: true}, options);\n    let model = this;\n    let success = options.success;\n    options.success = (resp) => {\n      let serverAttrs = options.parse ? model.parse(resp, options) : resp;\n      if (!model.set(serverAttrs, options)) {\n        return false;\n      }\n      if (success) {\n        success.call(options.context, model, resp, options);\n      }\n      model.trigger(\"sync\", model, resp, options);\n    };\n    wrapError(this, options);\n    return this.sync(\"read\", this, options);\n  };\n\n  /** Set a hash of model attributes, and sync the model to the server.\n   * If the server returns an attributes hash that differs, the model's\n   * state will be `set` again.\n   */\n  save(key, val, options) {\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    let attrs;\n    if (key == null || typeof key === \"object\") {\n      attrs = key;\n      options = val;\n    } else {\n      (attrs = {})[key] = val;\n    }\n\n    options = extend({validate: true, parse: true}, options);\n    let wait = options.wait;\n\n    // If we're not waiting and attributes exist, save acts as\n    // `set(attr).save(null, opts)` with validation. Otherwise, check if\n    // the model will be valid when the attributes, if any, are set.\n    if (attrs && !wait) {\n      if (!this.set(attrs, options)) {\n        return false;\n      }\n    } else if (!this._validate(attrs, options)) {\n      return false;\n    }\n\n    // After a successful server-side save, the client is (optionally)\n    // updated with the server-side state.\n    let model = this;\n    let success = options.success;\n    let attributes = this._attributes;\n    options.success = (resp) => {\n      // Ensure attributes are restored during synchronous saves.\n      model.attributes = attributes;\n      let serverAttrs = options.parse ? model.parse(resp, options) : resp;\n      if (wait) {\n        serverAttrs = extend({}, attrs, serverAttrs);\n      }\n      if (serverAttrs && !model.set(serverAttrs, options)) {\n        return false;\n      }\n      if (success) {\n        success.call(options.context, model, resp, options);\n      }\n      model.trigger(\"sync\", model, resp, options);\n    };\n    wrapError(this, options);\n\n    // Set temporary attributes if `{wait: true}` to properly find new ids.\n    if (attrs && wait) {\n      this._attributes = extend({}, attributes, attrs);\n    }\n\n    let method = this.isNew() ? \"create\" : (options.patch ? \"patch\" : \"update\");\n    if (method === \"patch\" && !options.attrs) {\n      options.attrs = attrs;\n    }\n    let request = this.sync(method, this, options);\n\n    // Restore attributes.\n    this._attributes = attributes;\n\n    return request;\n  };\n\n  /** Destroy this model on the server if it was already persisted.\n   * Optimistically removes the model from its collection, if it has one.\n   * If `wait: true` is passed, waits for the server to respond before removal.\n   */\n  destroy(options) {\n    options = options ? _clone(options) : {};\n    let model = this;\n    let success = options.success;\n    let wait = options.wait;\n\n    let destroy = () => {\n      model.stopListening();\n      model.trigger(\"destroy\", model, model.collection, options);\n    };\n\n    options.success = (resp) => {\n      if (wait) {\n        destroy();\n      }\n      if (success) {\n        success.call(options.context, model, resp, options);\n      }\n      if (!model.isNew()) {\n        model.trigger(\"sync\", model, resp, options);\n      }\n    };\n\n    let request = false;\n    if (this.isNew()) {\n      _defer(options.success);\n    } else {\n      wrapError(this, options);\n      request = this.sync(\"delete\", this, options);\n    }\n    if (!wait) destroy();\n    return request;\n  };\n\n  /** Default URL for the model's representation on the server -- if you're\n   * using restful methods, override this to change the endpoint\n   * that will be called.\n   */\n  url() {\n    let base =\n      _result(this, \"urlRoot\") ||\n      _result(this.collection, \"url\") ||\n      urlError();\n    if (this.isNew()) {\n      return base;\n    }\n    let id = this.get(this.idAttribute);\n    return base.replace(/[^\\/]$/, \"$&/\") + encodeURIComponent(id);\n  };\n\n  /**\n   * Keys of the attributes in this Model\n   */\n  keys() {\n    return Object.keys(this._attributes);\n  };\n\n  /**\n   * Values of the attributes in this Model\n   */\n  values() {\n    return Object.values(this._attributes);\n  };\n\n  /* if needed these can be used from lodash or underscore against the model's attributes\n  pairs() { // ??\n  };\n\n  invert() { // ??\n  };\n\n  pick() { // ??\n  };\n\n  omit() { // ??\n  };\n\n  chain() { // ??\n  };\n  */\n\n  /** Converts a response into the hash of attributes to be `set` on\n   * the model. The default implementation is just to pass the response along.\n   */\n  parse(resp, options) {\n    return resp;\n  };\n\n  /** Create a new model with identical attributes to this one.\n   */\n  clone() {\n    return new this.constructor(this._attributes);\n  };\n\n  /** A model is new if it has never been saved to the server, and lacks an id.\n   */\n  isNew() {\n    return !this.has(this.idAttribute);\n  };\n\n  /** Determine if the model has changed since the last `\"change\"` event.\n   * If you specify an attribute name, determine if that attribute has changed.\n   */\n  hasChanged(attr) {\n   if (attr == null) {\n     return !_isEmpty(this.changed);\n   }\n   return _has(this.changed, attr);\n  };\n\n  /** Return an object containing all the attributes that have changed, or\n   * false if there are no changed attributes. Useful for determining what\n   * parts of a view need to be updated and/or what attributes need to be\n   * persisted to the server. Unset attributes will be set to undefined.\n   * You can also pass an attributes object to diff against the model,\n   * determining if there *would be* a change.\n   */\n  changedAttributes(diff) {\n    if (!diff) {\n      return this.hasChanged() ? _clone(this.changed) : false;\n    }\n    let old = this._changing ? this._previousAttributes : this._attributes;\n    let changed = {};\n    let hasChanged;\n    for (let attr in diff) {\n      let val = diff[attr];\n      if (_isEqual(old[attr], val)) {\n        continue;\n      }\n      changed[attr] = val;\n      hasChanged = true;\n    }\n    return hasChanged ? changed : false;\n  };\n\n  /** Get the previous value of an attribute, recorded at the time the last\n   * `\"change\"` event was fired.\n   */\n  previous(attr) {\n    if (attr == null || !this._previousAttributes) {\n      return null;\n    }\n    return this._previousAttributes[attr];\n  };\n\n  /** Get all of the attributes of the model at the time of the previous\n   * `\"change\"` event.\n   */\n  previousAttributes() {\n    return _clone(this._previousAttributes);\n  };\n\n  /**\n   * supportsValidation - Returns True if this model supports validation\n   * @returns {boolean} Returns True if this model supports validation\n   */\n  supportsValidation() {\n    if (this.schema !== null) {\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * isValid - Returns True if this model is valid\n   * Runs two level validation, attribute-level then JSON Schema\n   * @returns {boolean} Returns True if this model is valid\n   */\n  isValid(options) {\n    const valid = this._validate({}, extend({}, options, {validate: true}));\n    if (valid) {\n      const messages = this.validate();\n      return this.validationMessages.valid;\n    }\n    return valid;\n  };\n  /**\n   * Validates the model\n   * @returns {array} Returns array of messages from validation\n   */\n  validate() {\n    if (!this._validationFramework) {\n      this._validationFramework = new ValidationFramework();\n    }\n    const v = this._validationFramework;\n\n    if (this.supportsValidation() && v.supportsValidation()) {\n      // validate from Validator\n      this.validationMessages = v.validate(this.toJSON(), this.schema);\n    } else {\n      this.validationMessages.valid = true;\n    }\n    return this.validationMessages;\n  };\n  /**\n   * Gets the validation messages only in an array\n   * @returns {array} Returns array of messages from validation\n   */\n  getValidationMessages() {\n    const messages = [];\n    if (this.validationMessages && this.validationMessages.errors) {\n      const l = this.validationMessages.errors.length;\n      var i = 0;\n      for (i = 0; i < l; i++) {\n        messages.push(this.validationMessages.errors[i].message + \" from \" + this.validationMessages.errors[i].dataPath);\n      }\n    }\n    return messages;\n  };\n  /**\n   * Sync model data to bound REST call\n   */\n  sync(method, model, options) {\n  };\n  /**\n   * reset - clear and rewrite the model with passed data\n   * @param {object} data The data to replace the model with (optional)\n   */\n  reset(data) {\n    this.clear();\n    if (data) {\n      this.set(data);\n    }\n  };\n\n  /**\n   * isEmpty - returns true is the model is empty\n   * @returns {boolean} returns true is the model is empty\n   */\n  isEmpty() {\n    return ( (this._attributes) ? (Object.keys(this._attributes).length === 0) : true );\n  };\n\n  /**\n   * toString - returns the model data as a string\n   * @returns {string} returns the model data as a string\n   */\n  toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\n  /**\n   * fetch - Fetches the model as a 'get'\n   */\n  fetch(options) {\n    this.sync(\"read\", this, options);\n  };\n  /**\n   * save - Saves the model as a 'create'\n   */\n  save(options) {\n    this.sync(\"create\", this, options);\n  };\n  /**\n   * update - Updates the model as a 'update'\n   */\n  update(options) {\n    this.sync(\"update\", this, options);\n  };\n  /**\n   * destroy - Deletes the model as a 'delete'\n   */\n  destroy(options) {\n    this.sync(\"delete\", this, options);\n  };\n\n  /** Run validation against the next complete set of model attributes,\n   * returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n   * @private\n   */\n  _validate(attrs, options) {\n    if (options && (!options.validate || !this.validate)) {\n      return true;\n    }\n    const messages = this.validate();\n    //attrs = extend({}, this._attributes, attrs);\n    //const error = this.validationError = this.validate(attrs, options);\n    //console.log(`Validate error ${JSON.stringify(error)}`);\n    //if (!error.valid) {\n    //  return true;\n    //}\n    if (messages.valid) {\n      return true;\n    }\n    this.trigger(\"invalid\", this, messages, extend(options, {validationError: messages}));\n    return false;\n  };\n};\n\nexport default AbstractModel;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","module.exports = __WEBPACK_EXTERNAL_MODULE__4__;","// CollectionIterator\n// ------------------\n\n// This \"enum\" defines the three possible kinds of values which can be emitted\n// by a CollectionIterator that correspond to the values(), keys() and entries()\n// methods on Collection, respectively.\nconst ITERATOR_VALUES = 1;\nconst ITERATOR_KEYS = 2;\nconst ITERATOR_KEYSVALUES = 3;\n\n/** A CollectionIterator implements JavaScript's Iterator protocol, allowing the\n * use of `for of` loops in modern browsers and interoperation between\n * Collection and other JavaScript functions and third-party libraries\n * which can operate on Iterables.\n */\nclass CollectionIterator {\n  constructor(collection, kind) {\n    this._collection = collection;\n    this._kind = kind;\n    this._index = 0;\n  };\n\n  // All Iterators should themselves be Iterable.\n  /* ???\n  if ($$iterator) {\n    CollectionIterator.prototype[$$iterator] = function() {\n      return this;\n    };\n  }*/\n\n  /**\n   * Next model in collection<br/>\n   * Once exhausted, remove the reference to the collection so future\n   * calls to the next method always return done.\n   */\n  next() {\n    if (this._collection) {\n      // Only continue iterating if the iterated collection is long enough.\n      if (this._index < this._collection.length) {\n        const model = this._collection.at(this._index);\n        this._index++;\n\n        // Construct a value depending on what kind of values should be iterated.\n        let value;\n        if (this._kind === ITERATOR_VALUES) {\n          value = model;\n        } else {\n          const id = this._collection.modelId(model.attributes);\n          if (this._kind === ITERATOR_KEYS) {\n            value = id;\n          } else { // ITERATOR_KEYSVALUES\n            value = [id, model];\n          }\n        }\n        return {value: value, done: false};\n      }\n\n      // Once exhausted, remove the reference to the collection so future\n      // calls to the next method always return done.\n      this._collection = void 0;\n    }\n    return {value: void 0, done: true};\n  };\n};\n\nexport default CollectionIterator;\n","import AbstractModel from \"./model/abstractModel.js\";\nimport AbstractCollection from \"./collection/collection.js\";\nimport CollectionIterator from \"./collection/iterator.js\";\n\nmodule.exports.AbstractModel = AbstractModel;\nmodule.exports.AbstractCollection = AbstractCollection;\nmodule.exports.CollectionIterator = CollectionIterator;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8__;","module.exports = __WEBPACK_EXTERNAL_MODULE__9__;","module.exports = __WEBPACK_EXTERNAL_MODULE__10__;","module.exports = __WEBPACK_EXTERNAL_MODULE__11__;","module.exports = __WEBPACK_EXTERNAL_MODULE__12__;","module.exports = __WEBPACK_EXTERNAL_MODULE__13__;","import { AugmentedObject } from \"next-core-object\";\nimport { extend, uniqueId, isString, isFunction, some, splice, sortObjects } from \"next-core-utilities\";\nimport AbstractModel from \"../model/abstractModel.js\";\nimport { ValidationFramework } from \"next-core-validation\";\nimport CollectionIterator from \"./iterator.js\";\n\nconst findModelByMatchingProperties = (set, properties) => {\n  return set.filter( (entry) => {\n    return Object.keys(properties).every( (key) => {\n      return entry._attributes[key] === properties[key];\n    });\n  });\n};\n\nconst _clone = require(\"lodash.clone\");\n\n// Default options for `Collection#set`.\nconst setOptions = {\n  add: true,\n  remove: true,\n  merge: true\n};\n\nconst addOptions = {\n  add: true,\n  remove: false\n};\n\n/**\n * Abstract Augmented Collection <br/>\n * Supports: <ul>\n * <li>Validation and Schemas</li>\n * <li>Security</li>\n * </ul>\n * @extends Object\n */\nclass AbstractCollection extends AugmentedObject {\n  constructor(models, options) {\n    super(options);\n\n    this.length = 0;\n    this.models = [];\n    this._byId = {};\n    this.schema = null;\n    this.validationMessages = {\n      valid: true\n    };\n\n    if (!options) {\n      options = {};\n    }\n    this.preinitialize(models, options);\n    if (options.model) {\n      this.model = options.model;\n    }\n    if (options.comparator !== void 0) {\n      this.comparator = options.comparator;\n    }\n    this._reset();\n    this.initialize(models, options);\n    if (models) {\n      // used to use reset but this collection never existed\n      this.add(models, extend({silent: true}, options));\n    }\n    if (!this.model) {\n      this.model = new AbstractModel();\n    }\n  };\n\n  /**\n   * Schema property\n   * @property {object} schema The JSON schema from this collection\n   */\n\n  /**\n   * Validation Message property\n   * @property {object} validationMessages The property holding validation message data\n   */\n\n  preinitialize(models, options) {\n  };\n\n  initialize(models, options) {\n  };\n\n  /** The JSON representation of a Collection is an array of the\n   * models\" attributes.\n   */\n  toJSON() {\n    //return this.map( (model) => { return model.toJSON(options); });\n    let i = 0;\n    const out = [], l = this.models.length;\n    for (i = 0; i < l; i++) {\n      out[i] = this.models[i].toJSON();\n    }\n    return out;\n  };\n\n  /*map(collection, interatee) {\n    return _map(collection, interatee);\n  };*/\n\n  /**\n   * Add a model, or list of models to the set. `models` may be\n   * Models or raw JavaScript objects to be converted to Models, or any\n   * combination of the two.\n   */\n  add(models, options) {\n    return this.set(models, extend({ merge: false }, options, addOptions));\n  };\n\n  /** Remove a model, or a list of models from the set.\n  */\n  remove(models, options) {\n    options = extend({}, options);\n    const singular = Array.isArray(models);\n    models = singular ? [models] : models.slice();\n    let removed = this._removeModels(models, options);\n    if (!options.silent && removed.length) {\n      options.changes = {added: [], merged: [], removed: removed};\n      this.trigger(\"update\", this, options);\n    }\n    return singular ? removed[0] : removed;\n  };\n\n  /** Update a collection by `set`-ing a new list of models, adding new ones,\n   * removing models that are no longer present, and merging models that\n   * already exist in the collection, as necessary. Similar to **Model#set**,\n   * the core operation for updating the data contained by the collection.\n   */\n  set(models, options) {\n    if (models === null) {\n      return;\n    }\n\n    options = extend({}, setOptions, options);\n    if (options.parse && !this._isModel(models)) {\n      models = this.parse(models, options) || [];\n    }\n\n    //console.debug(\"collection.add: models\", models);\n\n    let singular = !Array.isArray(models);\n    models = singular ? [models] : models.slice();\n\n    //console.debug(\"collection.add: singular\", singular);\n\n    let at = options.at;\n    if (at != null) at = +at;\n    if (at > this.length) at = this.length;\n    if (at < 0) at += this.length + 1;\n\n    let set = [];\n    let toAdd = [];\n    let toMerge = [];\n    let toRemove = [];\n    let modelMap = {};\n\n    let add = options.add;\n    let merge = options.merge;\n    let remove = options.remove;\n\n    //console.debug(\"collection.add: options add\", add);\n    //console.debug(\"collection.add: options merge\", merge);\n    //console.debug(\"collection.add: options remove\", remove);\n\n    let sort = false;\n    let sortable = this.comparator && at == null && options.sort !== false;\n    let sortAttr = isString(this.comparator) ? this.comparator : null;\n\n    // Turn bare objects into model references, and prevent invalid models\n    // from being added.\n    let model, i;\n    const l = models.length;\n\n    //console.debug(\"collection.add: num models\", l);\n\n    for (i = 0; i < l; i++) {\n      model = models[i];\n\n      //console.debug(\"collection.add: model\", i, model);\n\n      // If a duplicate is found, prevent it from being added and\n      // optionally merge it into the existing model.\n      let existing = this.get(model);\n\n      //console.debug(\"collection.add: existing\", i, existing);\n      if (existing) {\n        if (merge && model !== existing) {\n          let attrs = this._isModel(model) ? model._attributes : model;\n          if (options.parse) attrs = existing.parse(attrs, options);\n          existing.set(attrs, options);\n          toMerge.push(existing);\n          if (sortable && !sort) sort = existing.hasChanged(sortAttr);\n        }\n        if (!modelMap[existing.cid]) {\n          modelMap[existing.cid] = true;\n          set.push(existing);\n        }\n        models[i] = existing;\n\n      // If this is a new, valid model, push it to the `toAdd` list.\n      } else if (add) {\n        model = models[i] = this._prepareModel(model, options);\n\n        //console.debug(\"collection.add: add model\", i, model);\n\n        if (model) {\n          toAdd.push(model);\n          this._addReference(model, options);\n          modelMap[model.cid] = true;\n          set.push(model);\n        }\n      }\n    }\n\n    //console.debug(\"collection.add: set models\", set);\n    //console.debug(\"collection.add: toAdd models\", toAdd);\n    //console.debug(\"collection.add: toMerge models\", toMerge);\n\n    // Remove stale models.\n    if (remove) {\n      for (i = 0; i < this.length; i++) {\n        model = this.models[i];\n        if (!modelMap[model.cid]) toRemove.push(model);\n      }\n      if (toRemove.length) this._removeModels(toRemove, options);\n    }\n\n    // See if sorting is needed, update `length` and splice in new models.\n    let orderChanged = false;\n    let replace = !sortable && add && remove;\n    if (set.length && replace) {\n      orderChanged = this.length !== set.length || some(this.models, (m, index) => {\n        return m !== set[index];\n      });\n      this.models.length = 0;\n      splice(this.models, set, 0);\n      this.length = this.models.length;\n    } else if (toAdd.length) {\n      if (sortable) {\n        sort = true;\n      }\n      splice(this.models, toAdd, at == null ? this.length : at);\n      this.length = this.models.length;\n    }\n\n    // Silently sort the collection if appropriate.\n    if (sort) this.sort({silent: true});\n\n    // Unless silenced, it\"s time to fire all appropriate add/sort/update events.\n    if (!options.silent) {\n      for (i = 0; i < toAdd.length; i++) {\n        if (at != null) options.index = at + i;\n        model = toAdd[i];\n        model.trigger(\"add\", model, this, options);\n      }\n      if (sort || orderChanged) this.trigger(\"sort\", this, options);\n      if (toAdd.length || toRemove.length || toMerge.length) {\n        options.changes = {\n          added: toAdd,\n          removed: toRemove,\n          merged: toMerge\n        };\n        this.trigger(\"update\", this, options);\n      }\n    }\n\n    //console.debug(\"collection.add: finished models\", this.toJSON());\n\n    // Return the added (or merged) model (or models).\n    return singular ? models[0] : models;\n  };\n\n  /** When you have more items than you want to add or remove individually,\n   * you can reset the entire set with a new list of models, without firing\n   * any granular `add` or `remove` events. Fires `reset` when finished.\n   * Useful for bulk operations and optimizations.\n   */\n  reset(models, options) {\n    options = options ? _clone(options) : {};\n    for (let i = 0; i < this.models.length; i++) {\n      this._removeReference(this.models[i], options);\n    }\n    options.previousModels = this.models;\n    this._reset();\n    models = this.add(models, extend({silent: true}, options));\n    if (!options.silent) this.trigger(\"reset\", this, options);\n    return models;\n  };\n\n  /** Add a model to the end of the collection.\n  */\n  push(model, options) {\n    return this.add(model, extend({at: this.length}, options));\n  };\n\n  /** Remove a model from the end of the collection.\n   */\n  pop(options) {\n    const model = this.at(this.length - 1);\n    return this.remove(model, options);\n  };\n\n  /** Add a model to the beginning of the collection.\n   */\n  unshift(model, options) {\n    return this.add(model, extend({at: 0}, options));\n  };\n\n  /** Remove a model from the beginning of the collection.\n   */\n  shift(options) {\n    const model = this.at(0);\n    return this.remove(model, options);\n  };\n\n  /** Slice out a sub-array of models from the collection.\n   */\n  slice(...args) {\n    return this.models.slice(args);\n  };\n\n  /** Get a model from the set by id, cid, model object with id or cid\n   * properties, or an attributes object that is transformed through modelId.\n   */\n  get(obj) {\n    //console.debug(\"get\", obj);\n\n    if (obj == null) {\n      return void 0;\n    }\n\n    /*console.debug(\"_byId\", (this._byId[obj] ||\n      this._byId[this.modelId(this._isModel(obj) ? obj._attributes : obj)] ||\n      obj.cid && this._byId[obj.cid]));*/\n\n    return this._byId[obj] ||\n      this._byId[this.modelId(this._isModel(obj) ? obj._attributes : obj)] ||\n      obj.cid && this._byId[obj.cid];\n  };\n\n  /** Returns `true` if the model is in the collection.\n   */\n  has(obj) {\n    return (this.get(obj) !== null);\n  };\n\n  /** Get the model at the given index.\n   */\n  at(index) {\n    if (index < 0) {\n      index += this.length;\n    }\n    return this.models[index];\n  };\n\n  /** find the model that matches these properties\n   * @param {object} attrs properties to match\n   * @returns {Augmented.AbstractModel} model that matched\n   */\n  find(attrs) {\n    const results = findModelByMatchingProperties(this.models, attrs);\n    if (results && results.length > 0) {\n      return results[0];\n    }\n    return null;\n  };\n\n  /** filter the models that match these properties\n   * @param {object} attrs properties to match\n   * @returns {array} models that matched\n   */\n  filter(attrs) {\n    return findModelByMatchingProperties(this.models, attrs);\n  };\n\n  /** Return models with matching attributes. Useful for simple cases of `filter`.\n    * @param {object} attrs properties to match\n    * @returns {Augmented.AbstractModel|array} models that matched\n   */\n  where(attrs, first) {\n    if (first) {\n      return this.find(attrs);\n    }\n    return this.filter(attrs);\n  };\n\n  /** Return the first model with matching attributes. Useful for simple cases\n   * of `find`.\n   */\n  findWhere(attrs) {\n    return this.where(attrs, true);\n  };\n\n  /** Force the collection to re-sort itself. You don\"t need to call this under\n   * normal circumstances, as the set will maintain sort order as each item\n   * is added.\n   */\n  sort(options) {\n    let comparator = this.comparator;\n    if (!comparator) throw new Error(\"Cannot sort a set without a comparator\");\n    options || (options = {});\n\n    let length = comparator.length;\n    if (isFunction(comparator)) comparator = comparator.bind(this);\n\n    // Run sort based on type of `comparator`.\n    if (length === 1 || isString(comparator)) {\n      this.models = this.sortBy(comparator);\n    } else {\n      this.models.sort(comparator);\n    }\n    if (!options.silent) this.trigger(\"sort\", this, options);\n    return this;\n  };\n\n  /** Pluck an attribute from each model in the collection.\n   */\n  pluck(attr) {\n    let i = 0;\n    const out = [], l = this.models.length;\n    for (i = 0; i < l; i++) {\n      out[i] = this.models[i].toJSON()[attr];\n    }\n    return out;\n    //return this.map(attr + \"\");\n  };\n\n  /**\n   * Fetch the collection\n   */\n  fetch(options) {\n  };\n\n  /** Create a new instance of a model in this collection. Add the model to the\n   * collection immediately, unless `wait: true` is passed, in which case we\n   * wait for the server to agree.\n   */\n  create(model, options) {\n    options = options ? _clone(options) : {};\n    let wait = options.wait;\n    model = this._prepareModel(model, options);\n    if (!model) return false;\n    if (!wait) this.add(model, options);\n    let collection = this;\n    let success = options.success;\n    options.success = (m, resp, callbackOpts) => {\n      if (wait) collection.add(m, callbackOpts);\n      if (success) success.call(callbackOpts.context, m, resp, callbackOpts);\n    };\n    model.save(null, options);\n    return model;\n  };\n\n  /** **parse** converts a response into a list of models to be added to the\n   * collection. The default implementation is just to pass it through.\n   */\n  parse(resp, options) {\n    return resp;\n  };\n\n  /** Create a new collection with an identical list of models as this one.\n   */\n  clone() {\n    return new this.constructor(this.models, {\n      model: this.model,\n      comparator: this.comparator\n    });\n  };\n\n  /** Define how to uniquely identify models in the collection.\n   */\n  modelId(attrs) {\n    if (attrs && this.model && this.model.idAttribute) {\n      return attrs[this.model.idAttribute || \"id\"];\n    } else {\n      return \"id\";\n    }\n  };\n\n  /** Get an iterator of all models in this collection.\n   */\n  values() {\n    return new CollectionIterator(this, ITERATOR_VALUES);\n  };\n\n  /** Get an iterator of all model IDs in this collection.\n   */\n  keys() {\n    return new CollectionIterator(this, ITERATOR_KEYS);\n  };\n\n  /** Get an iterator of all [ID, model] tuples in this collection.\n   */\n  entries() {\n    return new CollectionIterator(this, ITERATOR_KEYSVALUES);\n  };\n\n  /**\n   * supportsValidation - Returns True if this collection supports validation\n   * @returns {boolean} Returns True if this collection supports validation\n   */\n  supportsValidation() {\n    const ret = (this.schema && this.schema !== null && this.schema !== {});\n    return (ret) ? true : false;\n  };\n\n  /**\n   * isValid - Returns True if this collection is valid\n   * @returns {boolean} Returns True if this collection is valid\n   */\n  isValid() {\n    return (this.validationMessages) ? this.validationMessages.valid : true;\n  };\n\n  /**\n   * getValidationMessages - Returns the validation messages\n   * @returns {array} Returns the message is an array of objects.\n   */\n  getValidationMessages() {\n    return (this.validationMessages && this.validationMessages.messages) ? this.validationMessages.messages : [];\n  };\n\n  /**\n   * Validates the collection\n   * @returns {array} Returns array of message from validation\n   */\n  validate() {\n    if (this.supportsValidation()) {\n      // validate from Validator\n      let messages = [];\n      this.validationMessages.messages = messages;\n      this.validationMessages.valid = true;\n      const a = this.toJSON(), l = (a && Array.isArray(a)) ? a.length : 0;\n      let i = 0;\n      if (!this._validationFramework) {\n        this._validationFramework = new ValidationFramework();\n      }\n      const v = this._validationFramework;\n\n      //console.debug(\"AUGMENTED: Collection Validate: Beginning with \" + l + \" models.\");\n      for (i = 0; i < l; i++) {\n        messages[i] = v.validate(a[i], this.schema);\n        if (!messages[i].valid) {\n          this.validationMessages.valid = false;\n        }\n      }\n\n      //logger.debug(\"AUGMENTED: Collection Validate: Completed isValid \" + this.validationMessages.valid);\n    } else {\n      this.validationMessages.valid = true;\n    }\n    return this.validationMessages;\n  };\n\n  /**\n   * Collecion.sync\n   */\n  sync(method, model, options) {\n  };\n\n  /**\n   * Collection.save - Saves the collection as a \"create\"\n   */\n  save(options) {\n    this.sync(\"create\", this, options);\n  };\n\n  /**\n   * Collection.update - Updates the collection as an \"update\"\n   */\n  update(options) {\n    this.sync(\"update\", this, options);\n  };\n\n  /**\n   * Collection.remove - Remove from the collection as a \"delete\"\n   */\n  remove(options) {\n    this.sync(\"delete\", this, options);\n  };\n\n  /**\n   * sortByKey - Sorts the collection by a property key\n   * @param {object} key The key to sort by\n   */\n  sortByKey(key) {\n    if (key) {\n      const data = this.toJSON();\n      if (data) {\n        const sorted = sortObjects(data, key);\n        this.reset(sorted);\n      }\n    }\n  };\n\n  /**\n   * isEmpty - returns true is the collection is empty\n   * @returns {boolean} returns true is the collection is empty\n   */\n  isEmpty() {\n    return (this.length === 0);\n  };\n  /**\n   * Collection.size - returns the size of the collection\n   * @returns {number} returns the size of the collection\n   */\n  size() {\n    return this.length;\n  };\n\n  /**\n   * toString - returns the collection data as a string\n   * @returns {string} returns the collection data as a string\n   */\n  toString() {\n    let ret = {};\n    try {\n      ret = JSON.stringify(this.toJSON());\n    } catch(e) {\n      console.error(e);\n    }\n    return ret;\n  };\n\n  /** Private method to reset all internal state. Called when the collection\n   * is first initialized or reset.\n   * @private\n   */\n  _reset() {\n    this.length = 0;\n    this.models = [];\n    this._byId  = {};\n  };\n\n  // Prepare a hash of attributes (or other model) to be added to this\n  // collection.\n  _prepareModel(attrs, options) {\n    if (this._isModel(attrs)) {\n      if (!attrs.collection) attrs.collection = this;\n      return attrs;\n    }\n    options = options ? _clone(options) : {};\n    options.collection = this;\n    const model = new AbstractModel(attrs, options); // used to be this.model, may be a problem if a custom model is passed.\n    if (!model.validationError) {\n      return model;\n    }\n    this.trigger(\"invalid\", this, model.validationError, options);\n    return false;\n  };\n\n  // Internal method called by both remove and set.\n  _removeModels(models, options) {\n    let removed = [];\n    for (let i = 0; i < models.length; i++) {\n      let model = this.get(models[i]);\n      if (!model) continue;\n\n      let index = this.at(model);\n      this.models.splice(index, 1);\n      this.length--;\n\n      // Remove references before triggering \"remove\" event to prevent an\n      // infinite loop. #3693\n      delete this._byId[model.cid];\n      let id = this.modelId(model._attributes);\n      if (id != null) delete this._byId[id];\n\n      if (!options.silent) {\n        options.index = index;\n        model.trigger(\"remove\", model, this, options);\n      }\n\n      removed.push(model);\n      this._removeReference(model, options);\n    }\n    return removed;\n  };\n\n  // Method for checking whether an object should be considered a model for\n  // the purposes of adding to the collection.\n  _isModel(model) {\n    return model instanceof AbstractModel;\n  };\n\n  // Internal method to create a model's ties to a collection.\n  _addReference(model, options) {\n    this._byId[model.cid] = model;\n    let id = this.modelId(model._attributes);\n    if (id != null) this._byId[id] = model;\n    model.on(\"all\", this._onModelEvent, this);\n  };\n\n  // Internal method to sever a model's ties to a collection.\n  _removeReference(model, options) {\n    delete this._byId[model.cid];\n    let id = this.modelId(model._attributes);\n    if (id != null) delete this._byId[id];\n    if (this === model.collection) delete model.collection;\n    model.off(\"all\", this._onModelEvent, this);\n  };\n\n  // Internal method called every time a model in the set fires an event.\n  // Sets need to update their indexes when models change ids. All other\n  // events simply proxy through. \"add\" and \"remove\" events that originate\n  // in other collections are ignored.\n  _onModelEvent(event, model, collection, options) {\n    if (model) {\n      if ((event === \"add\" || event === \"remove\") && collection !== this) return;\n      if (event === \"destroy\") this.remove(model, options);\n      if (event === \"change\") {\n        let prevId = this.modelId(model.previousAttributes());\n        let id = this.modelId(model._attributes);\n        if (prevId !== id) {\n          if (prevId != null) delete this._byId[prevId];\n          if (id != null) this._byId[id] = model;\n        }\n      }\n    }\n    this.trigger.apply(this, arguments);\n  };\n};\n\nexport default AbstractCollection;\n"],"sourceRoot":""}